\documentclass[11pt]{article}
\usepackage[paper=letterpaper,margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{listings}

\graphicspath{ {./images/} }

\setlength\parskip{1em plus 0.1em minus 0.2em}
\setlength\parindent{0pt}

\begin{document}

Capítulo 3 - Processos: Modelo Computacional

Ex. 1 - Considere o seguinte pseudo-código de um programa multitarefa com pthreads (por simplicidade, omitem-se verificações de erros):

\begin{lstlisting}
    T1.1.   int main(int argc, char **argv) {
    T1.2.       pthread_t tid;
    T1.3.       pthread_create(&tid, NULL, t2_start_routine, NULL);
    T1.4.       printf("A\n");
    T1.5.       pthread_join(tid, NULL);
    T1.6.       printf("B\n");
    T1.7.       return 0;
    T1.8.   }

    T2.1.   void *t2_start_routine(void *arg) {
    T2.2.       printf("C\n");}
    T2.3.       sleep(10); /* 10 segundos */
    T2.4.       return NULL;
    T2.5.   } 
\end{lstlisting}

a) Que saídas são possíveis observar quando executamos este programa? Justifique. Assuma apenas execuções em que nenhuma das funções chamadas devolvem erro.

Tanto pode acontecer "A\textbackslash nC\textbackslash nB\textbackslash n" como "C\textbackslash nA\textbackslash nB\textbackslash n". A partir da linha em que a nova tarefa é criada, ambas as tarefas executam-se concorrentemente, logo não há garantia de ordem entre as execuções de cada uma, o que explica porque os printf das linhas T1.4 e T2.2 podem acontecer em qualquer ordem. Na linha T1.5, a tarefa original espera até a segunda tarefa terminar (linha T2.4), logo o printf da linha T1.6 acontecerá necessariamente depois dos outros printf (assumindo execução sem falhas).

b) Ao longo da execução do programa existirão diferentes conjuntos de tarefas em execução. Indique como evolui o conjunto de tarefas, relacionando com as linhas do programa acima.

Uma tarefa até à linha T1.3, duas tarefas até à linha T2.4, uma tarefa a partir desse momento (assumindo execução sem falhas).

c) Caso a tarefa t2 queira devolver uma cadeia de caracteres (char*) à tarefa original para esta a imprimir com printf, como deveria o programa ser alterado?

Na função t2\_start\_routine:

\begin{lstlisting}[language=C]
            char *s = ...;
            ...
    T2.4.   return s;
\end{lstlisting}

Na função main:

\begin{lstlisting}[language=C]
            char *s;
    T1.5.   pthread_join(tid, &s);
    T1.6.   printf("%s", s);
\end{lstlisting}

\hrule

Ex. 2 - Considere um dado programa, com vários fios de execução, que tem 3 versões que se executam num computador uniprocessador com sistema operativo do tipo Unix e cuja funcionalidade não implica nenhuma operação de I/O:

\begin{itemize}
    \item versão V1 em que cada fio de execução é suportado por um processo,
    \item versão V2 em que cada fio de execução é suportado por uma tarefa real, e
    \item versão V3 em que cada fio de execução é suportado por uma pseudo-tarefa.
\end{itemize}

Note que as 3 versões têm exatamente a mesma funcionalidade.

a) Como compara as versões V1 e V2 no que respeita à robustez do programa? Na sua resposta considere, por exemplo, que um dos fios de execução faz uma divisão por zero.

A versão V1 é mais robusta, uma vez que apenas o processo onde ocorre o erro é terminado, continuando as restantes tarefas a executar-se. Na versão V2 o processo (que inclui todas as tarefas) é terminado. No caso de uma divisão por zero, em V1, apenas o fio de execução associado ao processo onde ocorre a divisão por zero termina (e todos os outros fios de execução continuam a sua execução normal) enquanto que em V2, todos os fios de execução são terminados.

b) Como compara as versões V1 e V3 no que respeita à robustez do programa? Na sua resposta considere, por exemplo, que um dos fios de execução faz uma divisão por zero.

Resposta idêntica à anterior.

c) Como compara as versões V1 e V2 no que respeita à rapidez de execução do programa?

V1 será mais lento, pois a criação de processos e comutação entre processos é mais lenta que a criação/comutação entre tarefas, dado que os processos não partilham o mesmo contexto.

d) Como compara as versões V1 e V3 no que respeita à rapidez de execução do programa?

Resposta idêntica à anterior.

e) Considere agora que o programa é executado numa máquina com dois processadores. Compare o desempenho das versões V2 e V3.

A versão V2 será mais rápida pois diferentes tarefas poderão executar-se concorrentemente nos dois processadores. Na versão V3, todas as pseudotarefas irão partilhar um único processador.

Sugestão: Rever Secção 3.4.2 - Modelo Multitarefa

\hrule

Ex. 3 - Considere um sistema operativo do tipo Unix no qual um processo executa o seguinte programa que se encontra num ficheiro "t.c"; "t.c" é compilado gerando um ficheiro executável "t.exe". Por simplicidade, omitem-se verificações de erros.

\begin{lstlisting}[language=C]
    1.  #include <stdio.h>
    2.  #include <stdlib.h>
    3.  main() {
    4.      int pid, pid_filho, status;
    5.      printf ("\nantes do fork pid=%d\n", getpid());
    6.      pid = fork();
    7.      if (pid == 0) {
    8.          printf ("pai=%d e filho=%d\n", getppid(), getpid());
    9.          execv ("t.exe",NULL);
    10.     }
    11.     else if (pid != -1){
    12.         pid_filho = wait(&status);
    13.         printf ("depois do wait feito pelo pid=%d obtendo pid_filho=%d\n", getpid(), pid_filho);
    14.         exit (0);
    15.     }
    16.     else {
    17.         printf ("erro no fork\n");
    18.         exit (-1);
    19.     }
    20. }
\end{lstlisting}


a) Quantos processos são criados?

Serão criados continuamente processos, de forma recursiva, até que se esgotem os recursos da máquina ou que os limites de utilização de recursos pelo utilizador sejam atingidos.

b) Assuma que o fork nunca retorna erro. A instrução depois do "wait" é executada?

Assumindo uma máquina e utilizador com recursos infinitos (logo o programa acima é capaz de criar um número infinito de processos filho), nenhum processo filho chega a terminar (assumindo também que a chamada "exec" nunca falha). Consequentemente, a função "wait" nunca retornará, logo alinha seguinte nunca será executada.

c) Assuma que o fork retorna erro na 3ª vez que é chamado. Considere que inicia a execução do programa "t.exe". Indique o seu output continuando o que se indica (antes do fork pid=2204).

antes do fork pid=2204 \\
pai=2204 e filho=2205 \\
antes do fork pid=2205 \\
pai=2205 e filho=2206 \\
antes do fork pid=2206 erro no fork \\
depois do wait feito pelo pid=2205 e obtendo pid\_filho=2206 \\
depois do wait feito pelo pid=2204 e obtendo pid\_filho=2205 \\
Os valores dos pids do processos apresentados podem ser outros pois isso depende do SO; no entanto, note que os valores em causa devem ser coerentes com a hierarquia dos processo em causa.

Sugestão: Rever Secção 3.5.2 - Operações sobre Processos

\hrule

Ex. 4 - É possível implementar o conceito de pseudoparalelismo sem recorrer ao núcleo do sistema operativo? Justifique.

Sim, é possível implementar o conceito de pseudoparalelismo através da utilização de co-rotinas ou pseudotarefas. A gestão das pseudotarefas é feita explicitamente pelo programador usando bibliotecas que se executam no espaço do utilizador, i.e., sem recorrer ao núcleo do sistema operativo. Em particular, a comutação de tarefas poderá ser feita: i) explicitamente, o que implica que o programador invoque a função de comutação de tarefa "yield", ou ii) implicitamente através da utilização do mecanismo de exceções com base num intervalo de tempo que, quando expira, gera um signal que é tratado por uma rotina que efetuará a comutação de tarefas.

Sugestão: Rever Secção 3.4.2.2 - Conceito de tarefa


\hrule

Ex. 5 - Considere o seguinte excerto de um programa Unix (por simplicidade, omitem-se verificações de erros):

\begin{lstlisting}[language=C]
    1.  int a; /* variável global */
    2.  main() {
    3.      a = 0;
    4.      if (fork() == 0) {
    5.          a++;
    6.          printf("\%d", a);
    7.          exit(0);
    8.      }
    9.      else {
    10.         pid = wait(\&estado);
    11.     }
    12.     printf("\%d", a);
    13. }
\end{lstlisting}


a) Qual a saída deste programa? Justifique.

Saída: '10'. O primeiro algarismo ('1') é impresso após a criação do processo filho e depois do incremento unitário à variável 'a', que depois é impressa (linha 6). O segundo algarismo ('0') é impresso pelo processo pai depois do processo filho terminar (linha 12). É de notar que os processos não partilham o mesmo espaço de endereçamento, razão pela qual a variável 'a' possui valores distintos nos dois processos.

b) Modifique-o de modo a obter outra sequência. Por simplicidade, omita verificações de erros. Justifique.

Várias respostas possíveis. Possível resposta:

\begin{lstlisting}[language=C]
    1.  int a; /* variável global */
    2.  main() {
    3.      a = 0;
    4.      if (fork() == 0) {
    5.          a++;
    6.          printf("\%d", a);
    7.          /* exit(0); */
    8.      }
    9.      else {
    10.         pid = wait(\&estado);
    11.     }
    12.     printf("\%d", a);
    13. }
\end{lstlisting}

Saída: '110'. Os primeiros dois '1's são impressos pelo filho (linhas 6 e 12). O '0' é impresso pelo pai (linha 12). O valor da variável 'a' no processo pais é zero pois apenas o filho incrementa a variável (linha 5). Uma vez que os processos não partilham o mesmo espaço de endereçamento, um incremento de uma variável no filho não tem qualquer efeito no processo do pai.

Sugestão: Rever Secção 3.5.2 - Operações sobre Processos

Ex. 6 - Para cada uma das seguintes afirmações, indique se esta pode ou não ser um motivo válido para a utilização de múltiplas tarefas reais (tarefas-núcleo) num programa que corre num sistema operativo Unix, e explique porquê:

a) Ter múltiplos fios de execução com espaços de endereçamento separados no mesmo programa.

Não; ao utilizar tarefas reais, o espaço de endereçamento é comum a todas as tarefas do mesmo processo.

b) Poder sobrepor a execução de instruções de E/S com a utilização do CPU por outras partes do mesmo programa.

Sim, ao utilizar tarefas reais, enquanto uma ou mais tarefas podem estar a tratar eventos de E/S, outras poderão estar a utilizar CPU.

c) Executar dois programas diferentes (correspondentes a diferentes ficheiros executáveis) em paralelo.

Não; tarefas reais não são necessárias para atingir paralelismo entre dois processos diferentes. As tarefas reais podem apenas trazer paralelismo dentro do mesmo processo (i.e., vários fios de execução em paralelo).

Sugestão: Rever Secção 3.4 - Modelos de Programação de Processos

Ex. 7 - Considere o seguinte excerto de um programa que usa signals em Unix (por simplicidade, omitem-se verificações de erros):

\begin{lstlisting}[language=C]
    1.  void trata_signal(int num) {
    2.      signal(SIGINT, trata_signal);
    3.      printf("Operação negada.");
    4.  }
    5.
    6.  int main(void) {
    7.      if (signal(SIGINT, trata_signal) == SIG_ERR)
    8.          {printf("Erro no signal");}
    9.      for (;;) {sleep(10);}
    10.     exit(0);
    11. }
\end{lstlisting}

a) Explique o comportamento deste programa.

O programa começa por instalar uma rotina de tratamento para o sinal 'SIGINT' usando a chamada de sistema "signal" e fazendo o teste devido para verificar o retorno da chamada de sistema. De seguida, o programa entra num ciclo "for" sem fim onde, a cada iteração, o programa suspende a sua execução durante 10 segundos (utilizando a chamada de sistema "sleep"). A rotina de tratamento do sinal "SIGINT", se chamada, re-instala o sinal e imprime uma mensagem para a output. É de notar que o sinal "SIGINT" pode ser gerado através da combinação das teclas CTRL+C.

b) Identifique todas as funções do sistema operativo e da biblioteca stdio que são utilizadas no programa e explique o que faz cada uma.

"printf" - imprime carateres para o output do processo;
"signal" - instala rotinas de tratamento de sinais;
"sleep" - suspende a execução da tarefa atual durante um período de tempo;
"exit" - termina a execução do processo.

c) De que forma um processo que corra este programa pode ser terminado? Justifique.

O processo pode ser terminado enviando um sinal cujo efeito sobre o processo é terminá-lo. Por exemplo, é possível utilizar a chamada de sistema "kill" com o sinal "SIGTERM" para terminar este processo.

Sugestão: Rever Secção 3.5.3 - Signals

Ex. 8 - Considere a chamada de sistema "kill" em Unix.

a) Explique o que faz esta função.

A chamada de sistema "kill" tem como propósito o envio de sinais a processos.

b) Esta função necessita de efetuar algumas validações de segurança. Explique quais e qual o motivo da sua existência.

Uma vez que a chamada de sistema "kill" pode interferir com outros processos, é importante garantir que, por exemplo, um utilizador sem privilégios de superutilizador não consiga interferir com processos do sistema (que estão associados ao superutilizador do sistema) ou com processos de outros utilizadores. Desta forma, usando a função de sistema "kill", apenas é possível enviar sinais a processos do mesmo UID. Apenas processos com privilégios de superutilizador podem ultrCapassar esta proteção.

c) O nome desta primitiva é enganador. Explique porquê.

É enganador pois a função não mata o processo, apenas envia sinais. A possível motivação para o nome resulta da implementação por omissão do tratamento da maioria dos sinais, que resulta no término do processo.

Sugestão: Rever Secção 3.5.3.4 - Operações Associadas aos Signals

Ex. 9 - Considere o seguinte código multitarefa (por simplicidade, omitem-se verificações de erros):

\begin{lstlisting}[language=C]
    1.  int i;
    2.  int main(int argc, char **argv) {
    3.      if(thread_create(t2_start_routine, (void*)0) == NULL) {exit(1);}
    4.      thread_yield(); /* comutação de tarefa */
    5.      for (i = 0; i < MAX; i++) {printf("t1\n");}
    6.      return 0;
    7.  }
    8.  void *t2_start_routine(void *arg) {
    9.      for(i = 0; i< MAX; i++) {printf("t2\n");}
    10.     sleep(10); /* 10 segundos */
    11.     return 0;
    12. }
\end{lstlisting}

Suponha que as rotinas "thread\_create" e "thread\_yield" são implementadas por uma biblioteca de co-rotinas (pseudotarefas).

a) Qual é a saída deste programa? Justifique.

Saída: 'MAX' linhas com 't2' seguidas de 'MAX' linhas com 't1'. Uma vez que este código usa pseudotarefas, cada tarefa vai executar-se (de acordo com o código apresentado) até que a outra chame a função "thread\_yield" ou termine. Assim sendo, a thread que executa a rotina 't2\_start\_routine' vai executar-se até terminar (daí as linhas com 't2' serem impressas todas seguidas). A outra thread (que invocou a função "thread\_yield") apenas imprime linhas com 't1' após a outra thread terminar.

b) A resposta à alínea anterior manter-se-ia se mudasse para tarefas reais? Justifique.

Não. Com tarefas reais, é possível que as linhas escritas por cada tarefa ficassem alternadas uma vez que é o núcleo do sistema operativo a decidir que tarefa corre em cada instante. Deste modo, como já não é o programador a decidir o escalonamento, ambas as tarefas vão executar-se concorrentemente.

c) Considerando ainda o código apresentado acima, consegue determinar o tempo mínimo que decorre entre a saída das diferentes tarefas? Qual é esse tempo mínimo? Justifique.

10 segundos é o tempo mínimo pois a tarefa que executa a função 't2\_start\_routine' executa um "sleep" antes de terminar. É de notar que a tarefa 't2' está a executar-se porque a tarefa 't1' invocou a função "thread\_yield", que retira 't1' de execução até que tarefa 't2' termine.

d) A resposta à alínea anterior manter-se-ia se mudasse para tarefas reais? Justifique.

Não, com tarefas reais, a saída de ambas as tarefas pode sair alternada pois a chamada a "thread\_yield" apenas faz com que a thread perca o tempo de CPU que lhe foi atribuído no último escalonamento. Desta forma, é possível que venha a ser escalonada novamente antes da thread 't2' terminar.

Sugestão: Rever Secção 3.5.4 - Tarefas-Interface POSIX

Ex. 10 - Considere o código do seguinte programa Unix (por simplicidade, omitem-se verificações de erros):

\begin{lstlisting}[language=C]
    1.  #include <stdio.h>
    2.  int a;
    3.  fn() {
    4.      a++;
    5.      printf("X %d\n", a);
    6.      exit(0);
    7.  }
    8.
    9.  main(int argc, char **argv) {
    10.     int val;
    11.     a = 0;
    12.     printf("Y %d\n", a);
    13.     if (fork() == 0) {fn();}
    14.     wait(&val);
    15.     printf("Z %d\n", a);
    16. }
\end{lstlisting}

a) Qual a saída deste programa? Se houver mais do que uma possibilidade, indique todas as possíveis saídas.

Saída possível 1: \\
Y 0 \\
X 1 \\
Z 0 \\

Saída possível 2 (se o "fork" falhar): \\
Y 0 \\
Z 0 \\

b) Escreva um novo programa que seja equivalente (no sentido de executar a mesma sequência de código, apesar de não ter necessariamente a mesma saída), exceto no seguinte aspeto: na linha 13 deve lançar uma nova tarefa em vez de um novo processo. Deve utilizar a interface POSIX para todas as funções relacionadas com as tarefas. Tenha o cuidado de atualizar as restantes funções do sistema operativo que são invocadas neste código em conformidade. Por simplicidade, omita verificações de erros.

\begin{lstlisting}[language=C]
    1.  #include <stdio.h>
    2.  int a;
    3.  void *fn(void *arg) {
    4.      a++;
    5.      printf("X %d\n", a);
    6.      return 0;
    7.  }
    8.
    9.  main(int argc, char **argv) {
    10.     pthread_t tid;
    11.     a = 0;
    12.     printf("Y %d\n", a);
    13.     pthread_create(&tid, NULL, fn, NULL);
    14.     pthread_join(tid, NULL);
    15.     printf("Z %d\n", a);
    16. }
\end{lstlisting}

c) Qual a saída do novo programa?

Saída possível 1: \\
Y 0 \\
X 1 \\
Z 1

Saída possível 2 (se o "pthread\_create" falhar): \\
Y 0 \\
Z 0

d) Ordene em termos de velocidade de comutação, da mais rápida para a mais lenta, as seguintes possibilidades para a execução deste programa:

Usando tarefas núcleo;
Usando pseudotarefas;
Usando processos;

Pseudotarefas, tarefas núcleo, processos.

e) Para a resposta anterior, explique a razão principal para a escolha relativa entre as tarefas núcleo e as pseudotarefas.

A principal razão prende-se com o facto da comutação de tarefas reais implicar mais custo do que a comutação de pseudotarefas pois no primeiro caso é preciso passar de modo de utilizador para modo núcleo e vice versa enquanto que no segundo caso a comutação apenas em modo de utilizador.

Sugestão: Rever Secção 3.4 - Modelos de Programação de Processos

\end{document}